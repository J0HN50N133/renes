// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml_int32 = require("rescript/lib/js/caml_int32.js");
var Instruction = require("./Instruction.bs.js");
var Belt_HashMap = require("rescript/lib/js/belt_HashMap.js");

function $$new(param) {
  return {
          register_a: 0,
          register_x: 0,
          register_y: 0,
          stack_pointer: 0,
          status: 0,
          pc: 0,
          memory: new Uint8Array(new ArrayBuffer(65535))
        };
}

function mem_read(cpu, addr) {
  return cpu.memory[addr];
}

function mem_read_2bytes(cpu, addr) {
  var lo = cpu.memory[addr];
  var hi = cpu.memory[addr + 1 | 0];
  return (hi << 8) | lo;
}

function mem_write(cpu, addr, data) {
  cpu.memory[addr] = data;
  
}

function mem_write_2bytes(cpu, addr, data) {
  var hi = (data >>> 8);
  var lo = data & 255;
  mem_write(cpu, addr, lo);
  return mem_write(cpu, addr + 1 | 0, hi);
}

function update_zero_flag(cpu, result) {
  cpu.status = result !== 0 ? cpu.status & 253 : cpu.status | 2;
  
}

function update_negative_flag(cpu, result) {
  var match = result & 128;
  cpu.status = match !== 0 ? cpu.status | 128 : cpu.status & 127;
  
}

function update_zero_and_negative_flags(cpu, result) {
  update_zero_flag(cpu, result);
  return update_negative_flag(cpu, result);
}

function update_overflow_flag_and_prune_result(cpu, result) {
  cpu.status = result > 255 ? cpu.status | 64 : cpu.status & 191;
  return result % 256;
}

function reset(cpu) {
  cpu.register_a = 0;
  cpu.register_x = 0;
  cpu.status = 0;
  cpu.pc = mem_read_2bytes(cpu, 65532);
  
}

function wrapping_add(bits, a, b) {
  return Caml_int32.mod_(a + b | 0, Math.pow(2, bits) | 0);
}

function wrapping_add_8(param, param$1) {
  return wrapping_add(8, param, param$1);
}

function wrapping_add_16(param, param$1) {
  return wrapping_add(16, param, param$1);
}

function get_operand_address(cpu, mode) {
  switch (mode) {
    case /* Immediate */0 :
        return cpu.pc;
    case /* ZeroPage */1 :
        return cpu.memory[cpu.pc];
    case /* ZeroPage_X */2 :
        var pos = cpu.memory[cpu.pc];
        return wrapping_add(16, pos, cpu.register_x);
    case /* ZeroPage_Y */3 :
        var pos$1 = cpu.memory[cpu.pc];
        return wrapping_add(16, pos$1, cpu.register_y);
    case /* Absolute */4 :
        return mem_read_2bytes(cpu, cpu.pc);
    case /* Absolute_X */5 :
        var base = mem_read_2bytes(cpu, cpu.pc);
        return wrapping_add(16, base, cpu.register_x);
    case /* Absolute_Y */6 :
        var base$1 = mem_read_2bytes(cpu, cpu.pc);
        return wrapping_add(16, base$1, cpu.register_y);
    case /* Indirect_X */7 :
        var base$2 = cpu.memory[cpu.pc];
        var ptr = wrapping_add(8, base$2, cpu.register_x);
        var lo = cpu.memory[ptr];
        var addr = wrapping_add(8, ptr, 1);
        var hi = cpu.memory[addr];
        return (hi << 8) | lo;
    case /* Indirect_Y */8 :
        var base$3 = cpu.memory[cpu.pc];
        var lo$1 = cpu.memory[base$3];
        var addr$1 = wrapping_add(8, base$3, 1);
        var hi$1 = cpu.memory[addr$1];
        var deref_base = (hi$1 << 8) | lo$1;
        return wrapping_add(16, deref_base, cpu.register_y);
    case /* NoneAddressing */9 :
        throw {
              RE_EXN_ID: Instruction.UnSupportedAddressingMode,
              Error: new Error()
            };
    
  }
}

function lda(cpu, mode) {
  var addr = get_operand_address(cpu, mode);
  cpu.register_a = cpu.memory[addr];
  return update_zero_and_negative_flags(cpu, cpu.register_a);
}

function tax(cpu) {
  cpu.register_x = cpu.register_a;
  return update_zero_and_negative_flags(cpu, cpu.register_x);
}

function inx(cpu) {
  cpu.register_x = cpu.register_x + 1 | 0;
  cpu.register_x = update_overflow_flag_and_prune_result(cpu, cpu.register_x);
  return update_zero_and_negative_flags(cpu, cpu.register_x);
}

function iny(cpu) {
  cpu.register_y = cpu.register_y + 1 | 0;
  cpu.register_y = update_overflow_flag_and_prune_result(cpu, cpu.register_y);
  return update_zero_and_negative_flags(cpu, cpu.register_y);
}

function sta(cpu, mode) {
  var addr = get_operand_address(cpu, mode);
  return mem_write(cpu, addr, cpu.register_a);
}

function interpret(cpu, program) {
  cpu.pc = 0;
  cpu.memory = program;
  var $$break = false;
  while(!$$break) {
    var op = cpu.memory[cpu.pc];
    cpu.pc = cpu.pc + 1 | 0;
    var instruction = Belt_HashMap.get(Instruction.instruction_table, op);
    if (instruction !== undefined) {
      var match = instruction.code;
      if (match >= 30) {
        if (match !== 47) {
          if (match !== 50) {
            
          } else {
            tax(cpu);
          }
        } else {
          sta(cpu, instruction.mode);
          cpu.pc = (cpu.pc + instruction.bytes | 0) - 1 | 0;
        }
      } else if (match !== 10) {
        if (match >= 25) {
          switch (match) {
            case /* INX */25 :
                inx(cpu);
                break;
            case /* INY */26 :
                iny(cpu);
                break;
            case /* JMP */27 :
            case /* JSR */28 :
                break;
            case /* LDA */29 :
                lda(cpu, instruction.mode);
                cpu.pc = (cpu.pc + instruction.bytes | 0) - 1 | 0;
                break;
            
          }
        }
        
      } else {
        $$break = true;
      }
    } else {
      throw {
            RE_EXN_ID: Instruction.ErrorInstruction,
            Error: new Error()
          };
    }
  };
  
}

function load(cpu, program) {
  cpu.pc = 32768;
  var len = program.length;
  for(var i = 0; i < len; ++i){
    cpu.memory[i] = program[i];
  }
  return mem_write(cpu, 65532, 32768);
}

function run(cpu) {
  var $$break = false;
  while(!$$break) {
    var op = cpu.memory[cpu.pc];
    cpu.pc = cpu.pc + 1 | 0;
    var instruction = Belt_HashMap.get(Instruction.instruction_table, op);
    if (instruction !== undefined) {
      var match = instruction.code;
      if (match >= 30) {
        if (match !== 47) {
          if (match !== 50) {
            
          } else {
            tax(cpu);
          }
        } else {
          sta(cpu, instruction.mode);
          cpu.pc = (cpu.pc + instruction.bytes | 0) - 1 | 0;
        }
      } else if (match !== 10) {
        if (match >= 25) {
          switch (match) {
            case /* INX */25 :
                inx(cpu);
                break;
            case /* INY */26 :
                iny(cpu);
                break;
            case /* JMP */27 :
            case /* JSR */28 :
                break;
            case /* LDA */29 :
                lda(cpu, instruction.mode);
                cpu.pc = (cpu.pc + instruction.bytes | 0) - 1 | 0;
                break;
            
          }
        }
        
      } else {
        $$break = true;
      }
    } else {
      throw {
            RE_EXN_ID: Instruction.ErrorInstruction,
            Error: new Error()
          };
    }
  };
  
}

function load_and_run(cpu, program) {
  load(cpu, program);
  reset(cpu);
  return run(cpu);
}

exports.$$new = $$new;
exports.mem_read = mem_read;
exports.mem_read_2bytes = mem_read_2bytes;
exports.mem_write = mem_write;
exports.mem_write_2bytes = mem_write_2bytes;
exports.update_zero_flag = update_zero_flag;
exports.update_negative_flag = update_negative_flag;
exports.update_zero_and_negative_flags = update_zero_and_negative_flags;
exports.update_overflow_flag_and_prune_result = update_overflow_flag_and_prune_result;
exports.reset = reset;
exports.wrapping_add = wrapping_add;
exports.wrapping_add_8 = wrapping_add_8;
exports.wrapping_add_16 = wrapping_add_16;
exports.get_operand_address = get_operand_address;
exports.lda = lda;
exports.tax = tax;
exports.inx = inx;
exports.iny = iny;
exports.sta = sta;
exports.interpret = interpret;
exports.load = load;
exports.run = run;
exports.load_and_run = load_and_run;
/* Instruction Not a pure module */
