// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Caml_int32 = require("rescript/lib/js/caml_int32.js");
var Instruction = require("./Instruction.bs.js");
var Belt_HashMap = require("rescript/lib/js/belt_HashMap.js");

function stack_reset(cpu) {
  cpu.stack = 253;
  
}

function status_2_vector(cpu) {
  return (((((((cpu.n << 7) + (cpu.v << 6) | 0) + (cpu.g << 5) | 0) + (cpu.b << 4) | 0) + (cpu.d << 3) | 0) + (cpu.i << 2) | 0) + (cpu.z << 1) | 0) + cpu.c | 0;
}

function vector_2_status(cpu, vector) {
  cpu.n = (vector & 128) === 0 ? 0 : 1;
  cpu.v = (vector & 64) === 0 ? 0 : 1;
  cpu.g = (vector & 32) === 0 ? 0 : 1;
  cpu.b = (vector & 16) === 0 ? 0 : 1;
  cpu.d = (vector & 8) === 0 ? 0 : 1;
  cpu.i = (vector & 4) === 0 ? 0 : 1;
  cpu.z = (vector & 2) === 0 ? 0 : 1;
  cpu.c = (vector & 1) === 0 ? 0 : 1;
  
}

function $$new(param) {
  return {
          register_a: 0,
          register_x: 0,
          register_y: 0,
          stack_pointer: 0,
          pc: 0,
          memory: new Uint8Array(new ArrayBuffer(65535)),
          stack: 253,
          n: 0,
          v: 0,
          g: 0,
          b: 0,
          d: 0,
          i: 0,
          z: 0,
          c: 0
        };
}

function mem_read(cpu, addr) {
  return cpu.memory[addr];
}

function mem_read_2bytes(cpu, addr) {
  var lo = cpu.memory[addr];
  var hi = cpu.memory[addr + 1 | 0];
  return (hi << 8) | lo;
}

function mem_write(cpu, addr, data) {
  cpu.memory[addr] = data;
  
}

function mem_write_2bytes(cpu, addr, data) {
  var hi = (data >>> 8);
  var lo = data & 255;
  mem_write(cpu, addr, lo);
  return mem_write(cpu, addr + 1 | 0, hi);
}

function update_zero_flag(cpu, result) {
  cpu.z = result !== 0 ? 0 : 1;
  
}

function update_negative_flag(cpu, result) {
  var match = result & 128;
  cpu.n = match !== 0 ? 1 : 0;
  
}

function update_zero_and_negative_flags(cpu, result) {
  update_zero_flag(cpu, result);
  return update_negative_flag(cpu, result);
}

function update_overflow_flag_and_prune_result(cpu, result) {
  cpu.v = result > 255 ? 1 : 0;
  return result % 256;
}

function reset(cpu) {
  cpu.register_a = 0;
  cpu.register_x = 0;
  vector_2_status(cpu, 0);
  cpu.pc = mem_read_2bytes(cpu, 65532);
  cpu.stack = 253;
  
}

function wrapping_add_with_carry(bits, a, b) {
  var sum = a + b | 0;
  var bound = Math.pow(2, bits) | 0;
  return [
          Caml_int32.mod_(sum, bound),
          Caml_int32.div(sum, bound)
        ];
}

function wrapping_add(bits, a, b) {
  return wrapping_add_with_carry(bits, a, b)[0];
}

function wrapping_add_8(param, param$1) {
  return wrapping_add(8, param, param$1);
}

function wrapping_add_with_carry_8(param, param$1) {
  return wrapping_add_with_carry(8, param, param$1);
}

function wrapping_add_16(param, param$1) {
  return wrapping_add(16, param, param$1);
}

function wrapping_add_with_carry_16(param, param$1) {
  return wrapping_add_with_carry(16, param, param$1);
}

function get_operand_address(cpu, mode) {
  switch (mode) {
    case /* Immediate */0 :
        return cpu.pc;
    case /* Relative */1 :
        var addr = cpu.memory[cpu.pc];
        if (addr < 128) {
          return cpu.pc + addr | 0;
        } else {
          return (cpu.pc + addr | 0) - 256 | 0;
        }
    case /* ZeroPage */2 :
        return cpu.memory[cpu.pc];
    case /* ZeroPage_X */3 :
        var pos = cpu.memory[cpu.pc];
        return wrapping_add(16, pos, cpu.register_x);
    case /* ZeroPage_Y */4 :
        var pos$1 = cpu.memory[cpu.pc];
        return wrapping_add(16, pos$1, cpu.register_y);
    case /* Absolute */5 :
        return mem_read_2bytes(cpu, cpu.pc);
    case /* Absolute_X */6 :
        var base = mem_read_2bytes(cpu, cpu.pc);
        return wrapping_add(16, base, cpu.register_x);
    case /* Absolute_Y */7 :
        var base$1 = mem_read_2bytes(cpu, cpu.pc);
        return wrapping_add(16, base$1, cpu.register_y);
    case /* Indirect */8 :
        var mem_addr = mem_read_2bytes(cpu, cpu.pc);
        if ((mem_addr & 255) !== 255) {
          return mem_read_2bytes(cpu, mem_addr);
        }
        var lo = cpu.memory[mem_addr];
        var hi = cpu.memory[mem_addr & 65280];
        return (hi << 8) | lo;
    case /* Indirect_X */9 :
        var base$2 = cpu.memory[cpu.pc];
        var ptr = wrapping_add(8, base$2, cpu.register_x);
        var lo$1 = cpu.memory[ptr];
        var addr$1 = wrapping_add(8, ptr, 1);
        var hi$1 = cpu.memory[addr$1];
        return (hi$1 << 8) | lo$1;
    case /* Indirect_Y */10 :
        var base$3 = cpu.memory[cpu.pc];
        var lo$2 = cpu.memory[base$3];
        var addr$2 = wrapping_add(8, base$3, 1);
        var hi$2 = cpu.memory[addr$2];
        var deref_base = (hi$2 << 8) | lo$2;
        return wrapping_add(16, deref_base, cpu.register_y);
    case /* NoneAddressing */11 :
        throw {
              RE_EXN_ID: Instruction.UnSupportedAddressingMode,
              Error: new Error()
            };
    
  }
}

function load_to_register(cpu, value) {
  update_zero_and_negative_flags(cpu, value);
  return value;
}

function add_to_register_a(cpu, data) {
  var sum = (cpu.register_a + data | 0) + cpu.c | 0;
  cpu.c = sum > 255 ? 1 : 0;
  var result = sum & 255;
  cpu.v = ((data ^ result) & (result ^ cpu.register_a) & 128) === 1 ? 1 : 0;
  update_zero_and_negative_flags(cpu, result);
  cpu.register_a = result;
  
}

function adc(cpu, mode) {
  var addr = get_operand_address(cpu, mode);
  var m = cpu.memory[addr];
  return add_to_register_a(cpu, m);
}

function logic_and_or_op(cpu, mode, op) {
  var addr = get_operand_address(cpu, mode);
  var m = cpu.memory[addr];
  cpu.register_a = Curry._2(op, cpu.register_a, m);
  return update_zero_and_negative_flags(cpu, cpu.register_a);
}

function and_(cpu, mode) {
  return logic_and_or_op(cpu, mode, (function (prim0, prim1) {
                return prim0 & prim1;
              }));
}

function ora(cpu, mode) {
  return logic_and_or_op(cpu, mode, (function (prim0, prim1) {
                return prim0 | prim1;
              }));
}

function get_operand_value_in_mem_or_a(cpu, mode) {
  if (mode >= 11) {
    return cpu.register_a;
  }
  var addr = get_operand_address(cpu, mode);
  return cpu.memory[addr];
}

function write_operand_to_mem_or_a(cpu, mode, value) {
  var wrap_value = value & 255;
  if (mode >= 11) {
    cpu.register_a = wrap_value;
  } else {
    mem_write(cpu, get_operand_address(cpu, mode), wrap_value);
  }
  return update_zero_and_negative_flags(cpu, value);
}

function asl(cpu, mode) {
  var val = get_operand_value_in_mem_or_a(cpu, mode);
  cpu.c = (val >>> 7) & 1;
  return write_operand_to_mem_or_a(cpu, mode, (val << 1));
}

function lsr_(cpu, mode) {
  var val = get_operand_value_in_mem_or_a(cpu, mode);
  cpu.c = val & 1;
  return write_operand_to_mem_or_a(cpu, mode, (val >>> 1));
}

function jmp_if_1(value, cpu, mode) {
  if (value === 1) {
    cpu.pc = get_operand_address(cpu, mode);
    return ;
  }
  
}

function jmp_if_0(value, cpu, mode) {
  if (value === 0) {
    cpu.pc = get_operand_address(cpu, mode);
    return ;
  }
  
}

function bcc(cpu, mode) {
  return jmp_if_0(cpu.c, cpu, mode);
}

function bcs(cpu, mode) {
  return jmp_if_1(cpu.c, cpu, mode);
}

function beq(cpu, mode) {
  return jmp_if_1(cpu.z, cpu, mode);
}

function bmi(cpu, mode) {
  return jmp_if_1(cpu.n, cpu, mode);
}

function bne(cpu, mode) {
  return jmp_if_0(cpu.z, cpu, mode);
}

function bpl(cpu, mode) {
  return jmp_if_0(cpu.n, cpu, mode);
}

function bvc(cpu, mode) {
  return jmp_if_0(cpu.v, cpu, mode);
}

function bvs(cpu, mode) {
  return jmp_if_1(cpu.v, cpu, mode);
}

function clc(cpu) {
  cpu.c = 0;
  
}

function cld(cpu) {
  cpu.d = 0;
  
}

function cli(cpu) {
  cpu.i = 0;
  
}

function clv(cpu) {
  cpu.v = 0;
  
}

function compare(cpu, mode, compare_with) {
  var addr = get_operand_address(cpu, mode);
  var m = cpu.memory[addr];
  cpu.c = m <= compare_with ? 1 : 0;
  return update_zero_and_negative_flags(cpu, compare_with - m | 0);
}

function cmp(cpu, mode) {
  return compare(cpu, mode, cpu.register_a);
}

function cpx(cpu, mode) {
  return compare(cpu, mode, cpu.register_x);
}

function cpy(cpu, mode) {
  return compare(cpu, mode, cpu.register_y);
}

function decrease(cpu, value) {
  var temp = value - 1 & 255;
  update_zero_and_negative_flags(cpu, temp);
  return temp;
}

function dec(cpu, mode) {
  var addr = get_operand_address(cpu, mode);
  var m = cpu.memory[addr];
  return mem_write(cpu, addr, decrease(cpu, m));
}

function dex(cpu) {
  cpu.register_x = decrease(cpu, cpu.register_x);
  
}

function dey(cpu) {
  cpu.register_y = decrease(cpu, cpu.register_y);
  
}

function eor(cpu, mode) {
  var addr = get_operand_address(cpu, mode);
  var m = cpu.memory[addr];
  cpu.register_a = m ^ cpu.register_a;
  return update_zero_and_negative_flags(cpu, cpu.register_a);
}

function increase(cpu, value) {
  var temp = value + 1 & 255;
  update_zero_and_negative_flags(cpu, temp);
  return temp;
}

function inc(cpu, mode) {
  var addr = get_operand_address(cpu, mode);
  var m = cpu.memory[addr];
  return mem_write(cpu, addr, increase(cpu, m));
}

function inx(cpu) {
  cpu.register_x = increase(cpu, cpu.register_x);
  
}

function iny(cpu) {
  cpu.register_y = increase(cpu, cpu.register_y);
  
}

function jmp(cpu, mode) {
  cpu.pc = get_operand_address(cpu, mode);
  
}

function jsr(cpu, mode) {
  cpu.pc = get_operand_address(cpu, mode);
  
}

function bit(cpu, mode) {
  var addr = get_operand_address(cpu, mode);
  var m = cpu.memory[addr];
  var temp = m & cpu.register_a;
  cpu.z = temp === 0 ? 1 : 0;
  cpu.n = (m << 7) & 1;
  cpu.v = (m << 6) & 1;
  
}

function lda(cpu, mode) {
  var addr = get_operand_address(cpu, mode);
  var value = cpu.memory[addr];
  update_zero_and_negative_flags(cpu, value);
  cpu.register_a = value;
  
}

function ldx(cpu, mode) {
  var addr = get_operand_address(cpu, mode);
  var value = cpu.memory[addr];
  update_zero_and_negative_flags(cpu, value);
  cpu.register_x = value;
  
}

function ldy(cpu, mode) {
  var addr = get_operand_address(cpu, mode);
  var value = cpu.memory[addr];
  update_zero_and_negative_flags(cpu, value);
  cpu.register_y = value;
  
}

function tax(cpu) {
  var value = cpu.register_a;
  update_zero_and_negative_flags(cpu, value);
  cpu.register_x = value;
  
}

function tay(cpu) {
  var value = cpu.register_a;
  update_zero_and_negative_flags(cpu, value);
  cpu.register_y = value;
  
}

function tya(cpu) {
  var value = cpu.register_y;
  update_zero_and_negative_flags(cpu, value);
  cpu.register_a = value;
  
}

function txa(cpu) {
  var value = cpu.register_x;
  update_zero_and_negative_flags(cpu, value);
  cpu.register_a = value;
  
}

function txs(cpu) {
  var value = cpu.register_x;
  update_zero_and_negative_flags(cpu, value);
  cpu.stack_pointer = value;
  
}

function tsx(cpu) {
  var value = cpu.stack_pointer;
  update_zero_and_negative_flags(cpu, value);
  cpu.register_x = value;
  
}

function store(cpu, mode, value) {
  var addr = get_operand_address(cpu, mode);
  return mem_write(cpu, addr, value);
}

function sta(cpu, mode) {
  return store(cpu, mode, cpu.register_a);
}

function stx(cpu, mode) {
  return store(cpu, mode, cpu.register_x);
}

function sty(cpu, mode) {
  return store(cpu, mode, cpu.register_y);
}

function interpret(cpu, program) {
  cpu.pc = 0;
  cpu.memory = program;
  var $$break = false;
  while(!$$break) {
    var op = cpu.memory[cpu.pc];
    cpu.pc = cpu.pc + 1 | 0;
    var instruction = Belt_HashMap.get(Instruction.instruction_table, op);
    if (instruction !== undefined) {
      var match = instruction.code;
      if (match >= 30) {
        if (match !== 47) {
          if (match !== 50) {
            
          } else {
            tax(cpu);
          }
        } else {
          sta(cpu, instruction.mode);
          cpu.pc = (cpu.pc + instruction.bytes | 0) - 1 | 0;
        }
      } else if (match !== 10) {
        if (match >= 25) {
          switch (match) {
            case /* INX */25 :
                inx(cpu);
                break;
            case /* INY */26 :
                iny(cpu);
                break;
            case /* JMP */27 :
            case /* JSR */28 :
                break;
            case /* LDA */29 :
                lda(cpu, instruction.mode);
                cpu.pc = (cpu.pc + instruction.bytes | 0) - 1 | 0;
                break;
            
          }
        }
        
      } else {
        $$break = true;
      }
    } else {
      throw {
            RE_EXN_ID: Instruction.ErrorInstruction,
            Error: new Error()
          };
    }
  };
  
}

function load(cpu, program) {
  cpu.pc = 32768;
  var len = program.length;
  for(var i = 0; i < len; ++i){
    cpu.memory[i + 32768 | 0] = program[i];
  }
  return mem_write_2bytes(cpu, 65532, 32768);
}

function stack_push(cpu, data) {
  mem_write(cpu, cpu.stack + cpu.stack_pointer | 0, data);
  cpu.stack_pointer = cpu.stack_pointer - 1 & 255;
  
}

function stack_push_2bytes(cpu, data) {
  var hi = (data >>> 8);
  var lo = data & 255;
  stack_push(cpu, hi);
  return stack_push(cpu, lo);
}

function stack_pop(cpu) {
  cpu.stack_pointer = cpu.stack_pointer + 1 & 255;
  return cpu.memory[cpu.stack + cpu.stack_pointer | 0];
}

function stack_pop_2bytes(cpu) {
  var lo = stack_pop(cpu);
  var hi = stack_pop(cpu);
  return (hi << 8) | lo;
}

function pc_safe(cpu) {
  return cpu.pc < cpu.memory.length;
}

function php(cpu) {
  var vector = status_2_vector(cpu);
  cpu.g = 1;
  return stack_push(cpu, vector);
}

function pla(cpu) {
  var data = stack_pop(cpu);
  update_zero_and_negative_flags(cpu, data);
  cpu.register_a = data;
  
}

function plp(cpu) {
  var g = cpu.g;
  var vector = stack_pop(cpu);
  vector_2_status(cpu, vector);
  cpu.g = g;
  
}

function sbc(cpu, mode) {
  var addr = get_operand_address(cpu, mode);
  var m = cpu.memory[addr];
  return add_to_register_a(cpu, (-m | 0) - 1 | 0);
}

function rol(cpu, mode) {
  var m = get_operand_value_in_mem_or_a(cpu, mode);
  var old_c = cpu.c;
  cpu.c = (m >>> 7) === 0 ? 0 : 1;
  m = (m << 1);
  m = m | old_c;
  return write_operand_to_mem_or_a(cpu, mode, m);
}

function ror(cpu, mode) {
  var m = get_operand_value_in_mem_or_a(cpu, mode);
  var old_c = cpu.c;
  cpu.c = (m & 1) === 0 ? 0 : 1;
  m = (m >>> 1);
  m = m | (old_c << 7);
  return write_operand_to_mem_or_a(cpu, mode, m);
}

function rti(cpu) {
  var vector = stack_pop(cpu);
  vector_2_status(cpu, vector);
  cpu.b = 0;
  cpu.g = 1;
  cpu.pc = stack_pop_2bytes(cpu);
  
}

function rts(cpu) {
  cpu.pc = stack_pop_2bytes(cpu) + 1 | 0;
  
}

function run(cpu) {
  var $$break = false;
  while(!$$break && pc_safe(cpu)) {
    var op = cpu.memory[cpu.pc];
    cpu.pc = cpu.pc + 1 | 0;
    var instruction = Belt_HashMap.get(Instruction.instruction_table, op);
    if (instruction !== undefined) {
      var match = instruction.code;
      switch (match) {
        case /* ADC */0 :
            adc(cpu, instruction.mode);
            break;
        case /* AND */1 :
            and_(cpu, instruction.mode);
            break;
        case /* ASL */2 :
            asl(cpu, instruction.mode);
            break;
        case /* BCC */3 :
            bcc(cpu, instruction.mode);
            break;
        case /* BCS */4 :
            bcs(cpu, instruction.mode);
            break;
        case /* BEQ */5 :
            beq(cpu, instruction.mode);
            break;
        case /* BIT */6 :
            bit(cpu, instruction.mode);
            break;
        case /* BMI */7 :
            bmi(cpu, instruction.mode);
            break;
        case /* BNE */8 :
            bne(cpu, instruction.mode);
            break;
        case /* BPL */9 :
            bpl(cpu, instruction.mode);
            break;
        case /* BRK */10 :
            $$break = true;
            cpu.i = 1;
            break;
        case /* BVC */11 :
            bvc(cpu, instruction.mode);
            break;
        case /* BVS */12 :
            bvs(cpu, instruction.mode);
            break;
        case /* CLC */13 :
            cpu.c = 0;
            break;
        case /* CLD */14 :
            cpu.d = 0;
            break;
        case /* CLI */15 :
            cpu.i = 0;
            break;
        case /* CLV */16 :
            cpu.v = 0;
            break;
        case /* CMP */17 :
            cmp(cpu, instruction.mode);
            break;
        case /* CPX */18 :
            cpx(cpu, instruction.mode);
            break;
        case /* CPY */19 :
            cpy(cpu, instruction.mode);
            break;
        case /* DEC */20 :
            dec(cpu, instruction.mode);
            break;
        case /* DEX */21 :
            dex(cpu);
            break;
        case /* DEY */22 :
            dey(cpu);
            break;
        case /* EOR */23 :
            eor(cpu, instruction.mode);
            break;
        case /* INC */24 :
            inc(cpu, instruction.mode);
            break;
        case /* INX */25 :
            inx(cpu);
            break;
        case /* INY */26 :
            iny(cpu);
            break;
        case /* JMP */27 :
            jmp(cpu, instruction.mode);
            break;
        case /* JSR */28 :
            jsr(cpu, instruction.mode);
            break;
        case /* LDA */29 :
            lda(cpu, instruction.mode);
            break;
        case /* LDX */30 :
            ldx(cpu, instruction.mode);
            break;
        case /* LDY */31 :
            ldy(cpu, instruction.mode);
            break;
        case /* LSR */32 :
            lsr_(cpu, instruction.mode);
            break;
        case /* NOP */33 :
            break;
        case /* ORA */34 :
            ora(cpu, instruction.mode);
            break;
        case /* PHA */35 :
            stack_push(cpu, cpu.register_a);
            break;
        case /* PHP */36 :
            php(cpu);
            break;
        case /* PLA */37 :
            pla(cpu);
            break;
        case /* PLP */38 :
            plp(cpu);
            break;
        case /* ROL */39 :
            rol(cpu, instruction.mode);
            break;
        case /* ROR */40 :
            ror(cpu, instruction.mode);
            break;
        case /* RTI */41 :
            rti(cpu);
            break;
        case /* RTS */42 :
            rts(cpu);
            break;
        case /* SBC */43 :
            sbc(cpu, instruction.mode);
            break;
        case /* SEC */44 :
            cpu.c = 1;
            break;
        case /* SED */45 :
            cpu.d = 1;
            break;
        case /* SEI */46 :
            cpu.i = 1;
            break;
        case /* STA */47 :
            sta(cpu, instruction.mode);
            break;
        case /* STX */48 :
            stx(cpu, instruction.mode);
            break;
        case /* STY */49 :
            sty(cpu, instruction.mode);
            break;
        case /* TAX */50 :
            tax(cpu);
            break;
        case /* TAY */51 :
            tay(cpu);
            break;
        case /* TSX */52 :
            tsx(cpu);
            break;
        case /* TXA */53 :
            txa(cpu);
            break;
        case /* TXS */54 :
            txs(cpu);
            break;
        case /* TYA */55 :
            tya(cpu);
            break;
        
      }
      cpu.pc = (cpu.pc + instruction.bytes | 0) - 1 | 0;
    } else {
      throw {
            RE_EXN_ID: Instruction.ErrorInstruction,
            Error: new Error()
          };
    }
  };
  
}

function load_and_run(cpu, program) {
  load(cpu, program);
  reset(cpu);
  return run(cpu);
}

var stack_init_val = 253;

exports.stack_init_val = stack_init_val;
exports.stack_reset = stack_reset;
exports.status_2_vector = status_2_vector;
exports.vector_2_status = vector_2_status;
exports.$$new = $$new;
exports.mem_read = mem_read;
exports.mem_read_2bytes = mem_read_2bytes;
exports.mem_write = mem_write;
exports.mem_write_2bytes = mem_write_2bytes;
exports.update_zero_flag = update_zero_flag;
exports.update_negative_flag = update_negative_flag;
exports.update_zero_and_negative_flags = update_zero_and_negative_flags;
exports.update_overflow_flag_and_prune_result = update_overflow_flag_and_prune_result;
exports.reset = reset;
exports.wrapping_add_with_carry = wrapping_add_with_carry;
exports.wrapping_add = wrapping_add;
exports.wrapping_add_8 = wrapping_add_8;
exports.wrapping_add_with_carry_8 = wrapping_add_with_carry_8;
exports.wrapping_add_16 = wrapping_add_16;
exports.wrapping_add_with_carry_16 = wrapping_add_with_carry_16;
exports.get_operand_address = get_operand_address;
exports.load_to_register = load_to_register;
exports.add_to_register_a = add_to_register_a;
exports.adc = adc;
exports.logic_and_or_op = logic_and_or_op;
exports.and_ = and_;
exports.ora = ora;
exports.get_operand_value_in_mem_or_a = get_operand_value_in_mem_or_a;
exports.write_operand_to_mem_or_a = write_operand_to_mem_or_a;
exports.asl = asl;
exports.lsr_ = lsr_;
exports.jmp_if_1 = jmp_if_1;
exports.jmp_if_0 = jmp_if_0;
exports.bcc = bcc;
exports.bcs = bcs;
exports.beq = beq;
exports.bmi = bmi;
exports.bne = bne;
exports.bpl = bpl;
exports.bvc = bvc;
exports.bvs = bvs;
exports.clc = clc;
exports.cld = cld;
exports.cli = cli;
exports.clv = clv;
exports.compare = compare;
exports.cmp = cmp;
exports.cpx = cpx;
exports.cpy = cpy;
exports.decrease = decrease;
exports.dec = dec;
exports.dex = dex;
exports.dey = dey;
exports.eor = eor;
exports.increase = increase;
exports.inc = inc;
exports.inx = inx;
exports.iny = iny;
exports.jmp = jmp;
exports.jsr = jsr;
exports.bit = bit;
exports.lda = lda;
exports.ldx = ldx;
exports.ldy = ldy;
exports.tax = tax;
exports.tay = tay;
exports.tya = tya;
exports.txa = txa;
exports.txs = txs;
exports.tsx = tsx;
exports.store = store;
exports.sta = sta;
exports.stx = stx;
exports.sty = sty;
exports.interpret = interpret;
exports.load = load;
exports.stack_push = stack_push;
exports.stack_push_2bytes = stack_push_2bytes;
exports.stack_pop = stack_pop;
exports.stack_pop_2bytes = stack_pop_2bytes;
exports.pc_safe = pc_safe;
exports.php = php;
exports.pla = pla;
exports.plp = plp;
exports.sbc = sbc;
exports.rol = rol;
exports.ror = ror;
exports.rti = rti;
exports.rts = rts;
exports.run = run;
exports.load_and_run = load_and_run;
/* Instruction Not a pure module */
